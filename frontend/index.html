<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Soroban BLS Ring-Signature Login demo</title>
  <style>
    body{font-family:sans-serif;margin:2em}
    #wallets button{margin:2px 4px}
    pre{background:#eee;padding:6px;height:120px;overflow:auto}
  </style>
</head>
<body>
<h2>BLS Ring-Signature – zero-knowledge login (Soroban test-net)</h2>

<!-- 1 – throw-away funding account -->
<button id="initAccountBtn">Create temporary (Friendbot-funded) account</button>
<p id="address"></p>

<!-- 2 – local ring generation -->
<label>Ring size:
  <input id="ringSize" type="number" min="1" value="3">
</label>
<button id="generateRingBtn" disabled>Generate ring</button>
<button id="initContractBtn" disabled>Initialise contract on-chain</button>

<!-- 3 – wallets + login buttons -->
<h3>Wallets</h3>
<div id="wallets"></div>

<!-- 4 – login counter -->
<h3>On-chain login counter: <span id="loginCount">-</span></h3>
<button id="refreshCount" disabled>Refresh counter</button>

<!-- log window -->
<pre id="log"></pre>

<script type="module">
/* =========================================================
   External libs – exactly the three requested
   =======================================================*/
import StellarSdk     from 'https://cdn.jsdelivr.net/npm/@stellar/stellar-sdk@latest/+esm';
import * as bls       from 'https://cdn.jsdelivr.net/npm/@chainsafe/bls@8.1.0/+esm';
import {ZqField}      from 'https://cdn.jsdelivr.net/npm/ffjavascript@0.3.0/+esm';

/* =========================================================
   Soroban RPC set-up
   =======================================================*/
const RpcServer = StellarSdk.SorobanRpc?.Server || StellarSdk.rpc.Server;
const server    = new RpcServer('https://soroban-testnet.stellar.org');
const network   = StellarSdk.Networks.TESTNET;
const contractId= 'CB3M4D6WDUQKNUHMD76QTEEF6H46J7RDKKSY7YL5RV2U5T6A3NS45WT6';

/* =========================================================
   Globals
   =======================================================*/
let kp, publicKey;                     // temp Stellar account
let ringSecrets = [], ringPubPts = [], ringPubBytes = [];
const FrMOD = 0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001n;
const Fr = new ZqField(FrMOD);

/* =========================================================
   UI helpers
   =======================================================*/
const logEl = id('log');
function log(m){ logEl.textContent += m + '\n'; logEl.scrollTop = logEl.scrollHeight; }
function id(x){ return document.getElementById(x); }
function concat(...a){
  let len = a.reduce((s,b)=>s+b.length,0), r=new Uint8Array(len),o=0;
  for(const b of a){ r.set(b,o); o+=b.length; } return r;
}
function rndBytes(n){ return crypto.getRandomValues(new Uint8Array(n)); }
function bytes2big(b){
  return BigInt('0x'+[...b].map(x=>x.toString(16).padStart(2,'0')).join(''));
}
function big2bytes32(bi){
  let h = bi.toString(16).padStart(64,'0');
  return Uint8Array.from(h.match(/../g).map(x=>parseInt(x,16)));
}
function g1ToBytes96(pt){ return pt.toRawBytes(false); }          // uncompressed
function bytesToG1(b){ return bls.PointG1.fromHex(b); }
function randFr(){ return bytes2big(rndBytes(32)) % FrMOD; }

/* =========================================================
   Friendbot-funded temp account
   =======================================================*/
id('initAccountBtn').onclick = async () => {
  kp = StellarSdk.Keypair.random();
  publicKey = kp.publicKey();
  id('address').textContent = `Temporary account: ${publicKey}`;
  try{
    await fetch(`https://friendbot.stellar.org?addr=${publicKey}`);
    log('✓ Account funded by Friendbot');
    id('generateRingBtn').disabled=false;
    id('refreshCount').disabled=false;
  }catch(e){ log('Friendbot error: '+e); }
};

/* =========================================================
   Generate ring (local only)
   =======================================================*/
id('generateRingBtn').onclick = () => {
  const n = +id('ringSize').value;
  ringSecrets=[]; ringPubPts=[]; ringPubBytes=[];
  id('wallets').innerHTML='';
  for(let i=0;i<n;i++){
    const sk = randFr();
    const pk = bls.PointG1.BASE.multiply(sk);       // public point
    ringSecrets.push(sk);
    ringPubPts.push(pk);
    ringPubBytes.push(g1ToBytes96(pk));

    const b=document.createElement('button');
    b.textContent=`Log-in with wallet #${i}`;
    b.onclick = ()=> login(i);
    id('wallets').appendChild(b);
  }
  log(`✓ Ring of ${n} keys generated`);
  id('initContractBtn').disabled=false;
};

/* =========================================================
   Initialise contract storage with the ring
   =======================================================*/
id('initContractBtn').onclick = async ()=>{
  try{
    const acc = await server.getAccount(publicKey);
    const contract = new StellarSdk.Contract(contractId);
    let tx = new StellarSdk.TransactionBuilder(acc,{fee:'100000',networkPassphrase:network})
              .addOperation(contract.call('init',ringPubBytes))
              .setTimeout(30).build();
    const sim = await server.simulateTransaction(tx);
    tx.setSorobanData(sim.result.soroban_data);
    tx.sign(kp);
    const res = await server.sendTransaction(tx);
    log('✓ init() sent: '+res.hash);
    id('initContractBtn').disabled=true;
    refreshCount();
  }catch(e){ log('init() error: '+e); }
};

/* =========================================================
   Ring-signature creation (mirrors Rust test helper)
   =======================================================*/
async function ringSign(msg, signer){
  const n = ringPubBytes.length;
  let a = randFr();
  let responses = Array.from({length:n}, randFr);

  // base = all pubkeys || msg
  let base = ringPubBytes.reduce((p,c)=>concat(p,c), new Uint8Array());
  base = concat(base,msg);

  // xs = a·G
  const xsBytes = g1ToBytes96(bls.PointG1.BASE.multiply(a));
  let pre = concat(base,xsBytes);
  let digest = new Uint8Array(await crypto.subtle.digest('SHA-256',pre));
  const c = new Array(n).fill(0n);
  let idx = (signer+1)%n;
  c[idx]=bytes2big(digest)%FrMOD;

  while(idx!==signer){
    const r  = responses[idx];
    const P  = ringPubPts[idx];
    const x1 = bls.PointG1.BASE.multiply(r);
    const x2 = P.multiply(c[idx]);
    const xi = x1.add(x2);
    let pre2 = concat(base,g1ToBytes96(xi));
    let d2   = new Uint8Array(await crypto.subtle.digest('SHA-256',pre2));
    c[(idx+1)%n]=bytes2big(d2)%FrMOD;
    idx=(idx+1)%n;
  }
  responses[signer]=Fr.sub(a,Fr.mul(c[signer],ringSecrets[signer]));
  return {
    challenge: big2bytes32(c[0]),
    responses: responses.map(big2bytes32)
  };
}

/* =========================================================
   Log-in (verify()) then refresh counter
   =======================================================*/
async function login(idx){
  try{
    const msg = new TextEncoder().encode('Ring sig demo');
    const sig = await ringSign(msg,idx);

    const acc = await server.getAccount(publicKey);
    const contract = new StellarSdk.Contract(contractId);
    let tx = new StellarSdk.TransactionBuilder(acc,{fee:'100000',networkPassphrase:network})
              .addOperation(contract.call('verify',msg,sig))
              .setTimeout(30).build();
    const sim = await server.simulateTransaction(tx);
    tx.setSorobanData(sim.result.soroban_data);
    tx.sign(kp);
    const res = await server.sendTransaction(tx);
    log(`✓ login tx (${idx}) sent: ${res.hash}`);
    refreshCount();
  }catch(e){ log('login error: '+e); }
}

/* =========================================================
   Read persistent counter (get_login_count())
   =======================================================*/
async function refreshCount(){
  try{
    const acc = await server.getAccount(publicKey);
    const contract = new StellarSdk.Contract(contractId);
    let tx = new StellarSdk.TransactionBuilder(acc,{fee:'100000',networkPassphrase:network})
              .addOperation(contract.call('get_login_count'))
              .setTimeout(30).build();
    const sim = await server.simulateTransaction(tx);
    const count = StellarSdk.getScValAsBigInt(sim.result.retval);
    id('loginCount').textContent = count.toString();
  }catch(e){ log('counter error: '+e); }
}
</script>
</body>
</html>