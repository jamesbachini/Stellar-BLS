<!--

Nb. There is a bug in this frontend where it verifies intermittently for a valid wallet.
Not sure what is causing it :(

-->
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Soroban – BLS12-381 Ring-Signature Demo</title>
<meta name="viewport" content="width=device-width,initial-scale=1">
<style>
 body{font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;background:#f5f7fb;margin:0;color:#172b4d}
 .wrap{max-width:960px;margin:40px auto;padding:24px;background:#fff;border-radius:12px;box-shadow:0 6px 18px rgba(0,0,0,.1)}
 h1{margin:0 0 20px;font-size:1.8rem}
 h2{margin:32px 0 12px;font-size:1.3rem}
 textarea,input[type=text]{width:100%;padding:8px 12px;font-size:1rem;border:1px solid #dfe1e6;border-radius:6px}
 button{cursor:pointer;background:#0064ff;color:#fff;border:none;padding:8px 18px;margin:6px 4px;border-radius:6px;font-size:.95rem}
 button:disabled{opacity:.45;cursor:not-allowed}
 code{font-family:SFMono-Regular,Consolas,monospace;font-size:.85rem;background:#eef2ff;padding:1px 4px;border-radius:4px}
 .good{color:#128200;font-weight:600}
 .bad{color:#c90d0d;font-weight:600}
 .card{border:1px solid #dfe3e9;border-radius:8px;padding:14px;margin-top:12px;background:#fafbfc}
</style>
</head>
<body>
<div class="wrap">
  <h1>Private transactions with Ring-Signatures on Soroban</h1>

  <p>Contract&nbsp;Id<br>
     <input id="cid" value="CCGODMFRVEVNZJGMOY7LWN3DGLT65BK56Q5W5WQX6NPDX2QBJKOLF264"></p>

  <h2>1 — compose a message</h2>
  <textarea id="msg">Free Roman Storm</textarea><br>
  <button id="genRing">Generate 3 key-pairs</button>

  <div id="ringArea"></div>

  <h2>2 — choose signer &amp; build ring-signature</h2>
  Signer index&nbsp;<input id="idx" value="1" style="width:40px">
  <button id="signBtn"   disabled>Create signature</button>
  <button id="localTest" disabled>Test locally</button>
  <pre id="sigOut">signature not yet built</pre>

  <h2>3 — contract verify()</h2>
  <button id="verifyBtn" disabled>Simulate verify()</button>
  <span id="verResult"></span>
</div>

<script type="module" src="https://cdn.jsdelivr.net/npm/@stellar/stellar-sdk/+esm"></script>
<script type="module">
/* ------------------------------------------------------------------ *
 *  Imports & utility helpers                                         *
 * ------------------------------------------------------------------ */
import * as bls   from "https://cdn.jsdelivr.net/npm/@noble/bls12-381/+esm";
import StellarSdk from "https://cdn.jsdelivr.net/npm/@stellar/stellar-sdk/+esm";

const CURVE_R = bls.CURVE.r;                    // group order of Fr
const modR  = x => ((x % CURVE_R) + CURVE_R) % CURVE_R;
const hex   = u8 => Array.from(u8).map(b=>b.toString(16).padStart(2,"0")).join("");
const to32  = bi => {
  let h = bi.toString(16).padStart(64,"0");
  return Uint8Array.from(h.match(/.{2}/g).map(b=>parseInt(b,16)));
};
const sha256 = async bytes => new Uint8Array(await crypto.subtle.digest("SHA-256",bytes));
const $ = id => document.getElementById(id);

/* ------------------------------------------------------------------ *
 *  Canonical serialisation for un-compressed G1 points:               *
 *  clear the three flag-bits in byte-0 (compression, sign, infinity)  *
 * ------------------------------------------------------------------ */
const canon = bytes => { const b = Uint8Array.from(bytes); b[0] &= 0x1f; return b; };

/* ------------------------------------------------------------------ *
 *  Use the *exact* generator that’s hard-coded inside the contract    *
 * ------------------------------------------------------------------ */
const G1_GEN_BYTES = Uint8Array.from([
  0x17,0xf1,0xd3,0xa7,0x31,0x97,0xd7,0x94,0x26,0x95,0x63,0x8c,0x4f,0xa9,0xac,0x0f,
  0xc3,0x68,0x8c,0x4f,0x97,0x74,0xb9,0x05,0xa1,0x4e,0x3a,0x3f,0x17,0x1b,0xac,0x58,
  0x6c,0x55,0xe8,0x3f,0xf9,0x7a,0x1a,0xef,0xfb,0x3a,0xf0,0x0a,0xdb,0x22,0xc6,0xbb,
  0x11,0x4d,0x1d,0x68,0x55,0xd5,0x45,0xa8,0xaa,0x7d,0x76,0xc8,0xcf,0x2e,0x21,0xf2,
  0x67,0x81,0x6a,0xef,0x1d,0xb5,0x07,0xc9,0x66,0x55,0xb9,0xd5,0xca,0xac,0x42,0x36,
  0x4e,0x6f,0x38,0xba,0x0e,0xcb,0x75,0x1b,0xad,0x54,0xdc,0xd6,0xb9,0x39,0xc2,0xca
]);
const G1_GEN = bls.PointG1.fromHex(G1_GEN_BYTES);

/* ------------------------------------------------------------------ *
 *  RPC helper (compatible with sdk 3.x & browser build)              *
 * ------------------------------------------------------------------ */
const RpcServer = StellarSdk.SorobanRpc?.Server || StellarSdk.rpc.Server;
const rpc       = new RpcServer("https://soroban-testnet.stellar.org");
const NETWORK   = StellarSdk.Networks.TESTNET;

/* ------------------------------ demo state ------------------------------ */
let ring = [];          // public keys (Uint8Array 96)
let priv = [];          // secret scalars (BigInt)
let sig  = null;        // {challenge, responses}
let msgU8=null;

/* ----------------------- 0. generate ring ----------------------- */
$("genRing").onclick = ()=>{
  ring=[]; priv=[]; sig=null;
  $("ringArea").innerHTML="";
  for(let i=0;i<3;i++){
    const sk = modR(BigInt("0x"+hex(bls.utils.randomBytes(32))));
    const pk = canon(G1_GEN.multiply(sk).toRawBytes(false));
    priv.push(sk); ring.push(pk);
    $("ringArea").innerHTML+=
      `<div class="card">idx ${i}<br>pk: <code>${hex(pk).slice(0,18)}…</code></div>`;
  }
  $("signBtn").disabled=false;
  $("verifyBtn").disabled=$("localTest").disabled=true;
  $("sigOut").textContent="signature not yet built";
  $("verResult").textContent="";
};

/* ----------------- 1. build ring-signature -------------------- */
$("signBtn").onclick = async ()=>{
  const n   = ring.length;
  const idx = parseInt($("idx").value);
  if(isNaN(idx)||idx<0||idx>=n) return alert("bad signer index");

  msgU8 = new TextEncoder().encode($("msg").value);

  /* ensure pk at idx is correct */
  ring[idx] = canon(G1_GEN.multiply(priv[idx]).toRawBytes(false));

  const randFr = () => modR(BigInt("0x"+hex(bls.utils.randomBytes(32))));
  const a      = randFr();
  const resp   = Array.from({length:n},randFr);

  /* base = concat(pk)||msg */
  const base = new Uint8Array(n*96 + msgU8.length);
  ring.forEach((pk,i)=>base.set(pk,96*i));
  base.set(msgU8,n*96);

  const xs  = canon(G1_GEN.multiply(a).toRawBytes(false));
  const pre = new Uint8Array(base.length+xs.length);
  pre.set(base); pre.set(xs,base.length);

  const c = new Array(n).fill(0n);
  let j   = (idx+1)%n;
  c[j]    = modR(BigInt("0x"+hex(await sha256(pre))));
  while(j!==idx){
    const rj = resp[j];
    const pj = bls.PointG1.fromHex(ring[j]);
    const x1 = G1_GEN.multiply(rj);
    const x2 = pj.multiply(c[j]);
    const xj = canon(x1.add(x2).toRawBytes(false));

    const pre2 = new Uint8Array(base.length+xj.length);
    pre2.set(base); pre2.set(xj,base.length);

    const ci1 = modR(BigInt("0x"+hex(await sha256(pre2))));
    j=(j+1)%n; c[j]=ci1;
  }
  resp[idx] = modR(a - c[idx]*priv[idx]);

  sig = {
    challenge: to32(c[0]),
    responses: resp.map(to32)
  };

  $("sigOut").textContent=
    `challenge : ${hex(sig.challenge)}\n`+
    `responses : [${sig.responses.map(r=>hex(r).slice(0,10)+"…").join(", ")}]`;
  $("localTest").disabled=false;
  $("verifyBtn").disabled=true;
  $("verResult").textContent="";
};

/* ---------------- 2. local verification ----------------------- */
async function localVerify(msg, ringArr, sigObj){
  let c = modR(BigInt("0x"+hex(sigObj.challenge)));
  const base = new Uint8Array(ringArr.length*96 + msg.length);
  ringArr.forEach((pk,i)=>base.set(pk,96*i));
  base.set(msg,ringArr.length*96);

  for(let j=0;j<ringArr.length;j++){
    const rj = modR(BigInt("0x"+hex(sigObj.responses[j])));
    const pj = bls.PointG1.fromHex(ringArr[j]);
    const x1 = G1_GEN.multiply(rj);
    const x2 = pj.multiply(c);
    const xj = canon(x1.add(x2).toRawBytes(false));

    const pre = new Uint8Array(base.length+xj.length);
    pre.set(base); pre.set(xj,base.length);

    c = modR(BigInt("0x"+hex(await sha256(pre))));
  }
  return c===modR(BigInt("0x"+hex(sigObj.challenge)));
}

$("localTest").onclick = async ()=>{
  const ok = await localVerify(msgU8,ring,sig);
  alert(`${ok?"✅":"❌"} local verify ${ok?"PASSED":"FAILED"}`);
  $("verifyBtn").disabled = !ok;
};

/* ---------------- 3. contract.verify via simulate ------------ */
$("verifyBtn").onclick = async ()=>{
  const cid = $("cid").value.trim(); if(!cid) return alert("cid required");
  const payer = StellarSdk.Keypair.random();

  try{await rpc.getAccount(payer.publicKey());}
  catch{
    await fetch(`https://friendbot-testnet.stellar.org?addr=${payer.publicKey()}`);
    await new Promise(r=>setTimeout(r,4000));
  }

  const B   = StellarSdk.xdr.ScVal.scvBytes;
  const Vec = a=>StellarSdk.xdr.ScVal.scvVec(a);
  const Sym = s=>StellarSdk.xdr.ScVal.scvSymbol(s);
  const Map = ent=>StellarSdk.xdr.ScVal.scvMap(
      ent.map(([k,v])=>new StellarSdk.xdr.ScMapEntry({key:Sym(k),val:v})));

  const ringVal = Vec(ring.map(pk=>B(pk)));
  const sigVal  = Map([
    ["challenge", B(sig.challenge)],
    ["responses", Vec(sig.responses.map(r=>B(r)))]
  ]);
  const msgVal  = B(msgU8);

  const contract = new StellarSdk.Contract(cid);
  let tx = new StellarSdk.TransactionBuilder(
              await rpc.getAccount(payer.publicKey()),
             {fee:"100",networkPassphrase:NETWORK})
            .addOperation(contract.call("verify", msgVal, ringVal, sigVal))
            .setTimeout(30).build();

  const sim = await rpc.simulateTransaction(tx);
  const ok  = StellarSdk.scValToNative(sim.result.retval);

  $("verResult").textContent = ok ? "✅ contract returned TRUE"
                                  : "❌ contract returned FALSE";
  $("verResult").className   = ok ? "good" : "bad";
};
</script>
</body>
</html>